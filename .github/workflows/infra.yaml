name: Infrastructure Manager

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform Action'
        required: true
        default: 'apply'
        type: choice
        options:
        - apply
        - destroy

permissions:
  id-token: write
  contents: read

jobs:
  manage-infra:
    runs-on: ubuntu-latest
    env:
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      RESOURCE_GROUP: "devops-portfolio-rg"
      CLUSTER_NAME: "devops-portfolio-aks"
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      # ---------------------------------------------------------
      # NEW STEP: PRE-DESTROY CLEANUP (Fixed)
      # ---------------------------------------------------------
      - name: ðŸ§¹ Pre-Destroy Cleanup
        if: ${{ github.event.inputs.action == 'destroy' }}
        working-directory: ./terraform   # <--- FIX 1: Must run inside the folder!
        run: |
          echo "âš ï¸ DESTROY ACTION DETECTED: Cleaning up Kubernetes Load Balancers first..."
          
          # 1. Login to Azure
          az login --service-principal -u $ARM_CLIENT_ID -p $ARM_CLIENT_SECRET --tenant $ARM_TENANT_ID --output none
          az account set --subscription $ARM_SUBSCRIPTION_ID
          
          # 2. Check if cluster exists
          if ! az aks show --resource-group $RESOURCE_GROUP --name $CLUSTER_NAME > /dev/null 2>&1; then
            echo "Cluster not found. Skipping cleanup."
            exit 0
          fi

          # 3. Get Credentials (for kubectl commands)
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $CLUSTER_NAME --overwrite-existing

          # 4. INITIALIZE TERRAFORM
          # FIX 2: Using standard init to match your main step. 
          # If you use a backend.tf file, this is all you need.
          terraform init

          # 5. FORCE CLEANUP (Cluster + State)
          
          echo "   -> Processing Ingress Controller..."
          # Note: We run kubectl, but we don't care if it fails (|| true)
          kubectl delete namespace ingress-nginx --timeout=60s --ignore-not-found=true || true
          terraform state rm helm_release.nginx_ingress || true
          
          echo "   -> Processing Argo CD..."
          kubectl delete namespace argocd --timeout=60s --ignore-not-found=true || true
          terraform state rm helm_release.argocd || true

          echo "   -> Processing Argo Rollouts..."
          kubectl delete namespace argo-rollouts --timeout=60s --ignore-not-found=true || true
          terraform state rm helm_release.argo_rollouts || true

          # 6. Wait for Azure to detach the IP
          echo "   -> Pausing 45s to allow Azure Load Balancer cleanup..."
          sleep 45
          echo "âœ… Cleanup Complete. State is synced. Handing over to Terraform."

      # ---------------------------------------------------------
      # STANDARD TERRAFORM EXECUTION
      # ---------------------------------------------------------
      - name: Terraform Run
        working-directory: ./terraform
        run: |
          terraform init
          terraform ${{ github.event.inputs.action }} -auto-approve

      # ---------------------------------------------------------
      # POST-APPLY: GET URLS
      # ---------------------------------------------------------
      - name: ðŸ“Š Get Access Info
        if: ${{ github.event.inputs.action == 'apply' }}
        run: |
          # Login again just to be safe (sessions can time out)
          az login --service-principal -u $ARM_CLIENT_ID -p $ARM_CLIENT_SECRET --tenant $ARM_TENANT_ID --output none
          az account set --subscription $ARM_SUBSCRIPTION_ID
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $CLUSTER_NAME --overwrite-existing

          echo "â³ Waiting for NGINX Ingress to receive Public IP..."
          
          NGINX_IP=""
          while [ -z "$NGINX_IP" ]; do
            NGINX_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
            if [ -z "$NGINX_IP" ]; then
              echo "   (Waiting for Azure IP...)"
              sleep 10
            fi
          done

          ARGO_PWD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          DNS_NAME="tapan-gitops-app.eastus2.cloudapp.azure.com"

          echo "====================================================="
          echo "ðŸš€ DEPLOYMENT SUCCESSFUL!"
          echo "ðŸ‘‰ App URL:      http://${DNS_NAME}/"
          echo "ðŸ‘‰ Argo URL:     http://${DNS_NAME}/argocd/"
          echo "ðŸ”‘ Argo Pass:    $ARGO_PWD"
          echo "====================================================="